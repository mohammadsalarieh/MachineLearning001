<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>GridWorld Modular</title>
<style>
canvas { border:1px solid #aaa; }
body { font-family: sans-serif; }
button { margin: 5px; }
</style>
</head>
<body>
<h2>GridWorld Modular</h2>
<input type="number" value="5" onchange="gridSize = Number(this.value); cellSize = 400/gridSize; resetGame()">
<button onclick="resetGame()">Reset</button><button onclick="resetGame();start()">Start</button>
<span id="stat"></span>
<canvas id="canvas" width="400" height="400"></canvas>
<img src="QLike.png" alt="Qlike||created by microsoft word 2019">
<script>
let canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d")
let gridSize = 5, cellSize = 400/gridSize
let agent = {x:0,y:0}, goal = {x:gridSize-1,y:gridSize-1}, goalsReached=0
function drawMap(){ctx.clearRect(0,0,400,400);ctx.strokeStyle="#ddd";for(let i=0;i<=gridSize;i++){ctx.beginPath();ctx.moveTo(i*cellSize,0);ctx.lineTo(i*cellSize,400);ctx.stroke();ctx.beginPath();ctx.moveTo(0,i*cellSize);ctx.lineTo(400,i*cellSize);ctx.stroke()}}
function drawAgent(){ctx.fillStyle="dodgerblue";ctx.fillRect(agent.x*cellSize,agent.y*cellSize,cellSize,cellSize)}
function drawGoal(){ctx.fillStyle="limegreen";ctx.fillRect(goal.x*cellSize,goal.y*cellSize,cellSize,cellSize)}
function moveAgent(d){if(d==="up"&&agent.y>0)agent.y--;if(d==="down"&&agent.y<gridSize-1)agent.y++;if(d==="left"&&agent.x>0)agent.x--;if(d==="right"&&agent.x<gridSize-1)agent.x++;drawMap();drawGoal();drawAgent()}
function resetGame(){agent={x:0,y:0};goal={x:gridSize-1,y:gridSize-1};drawMap();drawGoal();drawAgent()}
resetGame()
let stat = document.getElementById("stat")
function setStat(t,type = "info"){
    if(type === "info"){
        stat.style.color = "blue"
    }
    else if(type === "warn"){
        stat.style.color = "yellow"
    }
        else if(type === "eror"){
        stat.style.color = "red"
    }
    stat.textContent = t
}



function start(){
let memory = []
let episodeMoves = []
let numOfAttempts = 0
let numOfMove = 0
let bestMovement = gridSize*2-2
let preEs = gridSize*gridSize
let interval = setInterval(()=>{
    if(preEs === bestMovement){
        setStat("best route found! number of try for find route: "+numOfAttempts);
        clearInterval(interval);
        return
    }   
    if(agent.x===goal.x && agent.y===goal.y){
        goalsReached++;
        memory.push({series: [...episodeMoves], length: episodeMoves.length});
        preEs = episodeMoves.length
        console.info("movement number: " + episodeMoves.length)
        episodeMoves = [];
        numOfAttempts++
        resetGame();
        return;
    }    
    const actions = ["right","up","left","down"]
    const currentLoc = agent
    let nextSelection = {x:currentLoc.x+1,y:currentLoc.y}
    let reward = 0
    let action;
    let successRate = Number((bestMovement / preEs).toFixed(2));
    setStat("success rate is: " + successRate + "; best movements: " + bestMovement + "; current movements: " + preEs + ";")
    console.info("% of success road: " + successRate)
    if(Math.random() > successRate){
        action = actions[Math.floor(Math.random()*4)];
        console.log("action set with random number")
        let exists = memory.some(e => e.loc[0] === currentLoc[0] && e.loc[1] === currentLoc[1] && e.act === action);
        
        if(!exists){
            
            preSelection = {loc: currentLoc, act: action, rew: 0}
        }
    }
    else{
        let entries = memory.filter(e =>
        e.loc && 
        e.loc.x === currentLoc.x &&
        e.loc.y === currentLoc.y
    );
    
    action = actions[Math.floor(Math.random()*4)]; // default random
    
    if (entries.length > 0) {
        let bestEntry = entries.reduce((best, e) =>
            e.rew > best.rew ? e : best
        , entries[0]);
        if (bestEntry.rew > 0) {
            action = bestEntry.act;
            console.log("action selected by memory: act: ", action , " , rew: " , bestEntry.rew);
        } else {
            console.log("memory action ignored (negative reward)");
        }
    }
    
    }
    nextSelection = [
            agent.x + (action==="right" ? 1 : action==="left" ? -1 : 0),
            agent.y + (action==="down" ? 1 : action==="up" ? -1 : 0)
    ];
    let nextX = nextSelection[0];
    let nextY = nextSelection[1];
    if (nextX < 0 || nextX >= gridSize || nextY < 0 || nextY >= gridSize) {
        reward = -5;            // یا خیلی کمتر مثل -2
        console.log("❌ out of bounds");
    } else {
        let oldDist = Math.abs(goal.x - currentLoc.x) + Math.abs(goal.y - currentLoc.y);
        let newDist = Math.abs(goal.x - nextX) + Math.abs(goal.y - nextY);

        console.log("old:", oldDist, "new:", newDist);

        if (newDist < oldDist) reward = 1;
        else if (newDist > oldDist) reward = -1;
        else reward = -0.2;
    }
    console.log(`loc: [${currentLoc.x},${currentLoc.y}] act: ${action} rew: ${reward}`);
    console.log("choosed direction: " + action)
    memory.push({
        loc: {x: currentLoc.x, y: currentLoc.y},
        act: action, 
        rew: reward
    });
    
    episodeMoves.push(action);
    moveAgent(action);numOfMove++;
    

},50)
}

</script>
</body>
</html>
